package org.scalaide.worksheet.eval

import org.eclipse.jface.text.IDocument

import java.io.FileWriter

import scala.tools.eclipse.ScalaProject
import scala.tools.eclipse.buildmanager.sbtintegration.BasicConfiguration
import scala.tools.eclipse.buildmanager.sbtintegration.ScalaCompilerConf
import scala.tools.nsc.CompilerCommand
import scala.tools.nsc.interpreter.AbstractFileClassLoader
import scala.tools.nsc.io.AbstractFile
import scala.tools.nsc.io.VirtualDirectory
import scala.tools.nsc.reporters.ConsoleReporter
import scala.tools.nsc.scratchpad.Executor
import scala.tools.nsc.scratchpad.SourceInserter

/** An evaluator for worksheet documents.
 *
 *  It evaluates the contents of the given document and returns the sourcecode
 *  augmented with comments containing the result of the evaluation of each expression
 *  in the file.
 *
 */
class WorksheetEvaluator(scalaProject: ScalaProject, doc: IDocument) {

  /** Evaluate the instrumented code and return the result of the execution.
   *  It is typically the original source code with comments containing the reulst of
   *  the evaluation of each expression.
   *
   *  @param fullName The full name of the main class
   *  @param instrumented The instrumented source code (typically returned from `askInstrumented`)
   */
  def eval(fullName: String, instrumented: Array[Char]): Array[Char] = {
    val iSourceName = writeInstrumented(fullName, instrumented)

    // TODO: extract a better API for getting the configuration of the Scala compiler (should be in ScalaProject)
    val args = new BasicConfiguration(scalaProject, ScalaCompilerConf.deployedInstance)
    val vdirOpt = compileInstrumented(iSourceName, args.buildArguments(List()).toList ++ List("-verbose"))
    runInstrumented(vdirOpt, fullName, doc.get.toCharArray)
  }

  /** Write instrumented source file to disk.
   *  @param iFullName  The full name of the first top-level object in source
   *  @param iContents  An Array[Char] containing the instrumented source
   *  @return The name of the instrumented source file
   */
  private def writeInstrumented(iFullName: String, iContents: Array[Char]): String = {
    val iSimpleName = iFullName drop ((iFullName lastIndexOf '.') + 1)
    val iSourceName = iSimpleName + "$instrumented.scala"
    val ifile = new FileWriter(iSourceName)
    ifile.write(iContents)
    ifile.close()
    iSourceName
  }

  /** Compile instrumented source file
   *  @param iSourceName The name of the instrumented source file
   *  @param arguments   Further argumenrs to pass to the compiler
   *  @return Optionallu, if no -d option is given, the virtual directory
   *          contained the generated bytecode classes
   */
  private def compileInstrumented(iSourceName: String, arguments: List[String]): Option[AbstractFile] = {
    println("compiling " + iSourceName)
    val command = new CompilerCommand(iSourceName :: arguments, println(_))
    val virtualDirectoryOpt =
      if (arguments contains "-d")
        None
      else {
        val vdir = new VirtualDirectory("(memory)", None)
        command.settings.outputDirs setSingleOutput vdir
        Some(vdir)
      }
    val compiler = new scala.tools.nsc.Global(command.settings, new ConsoleReporter(command.settings))
    val run = new compiler.Run()
    println("compiling: " + command.files)
    run compile command.files
    virtualDirectoryOpt
  }

  /** Run instrumented bytecode file
   *  @param vdir       Optionally, the virtual directory containing the generated bytecode classes
   *  @param iFullName  The full name of the generated object
   *  @param stripped   The contents original source file without any right hand column comments.
   *  @return The generated file content containing original source in the left column
   *          and outputs in the right column
   */
  private def runInstrumented(vdirOpt: Option[AbstractFile], iFullName: String, stripped: Array[Char]): Array[Char] = {
    val defaultClassLoader = getClass.getClassLoader
    val classLoader = vdirOpt match {
      case Some(vdir) => new AbstractFileClassLoader(vdir, defaultClassLoader)
      case None       => defaultClassLoader
    }
    println("running " + iFullName)
    val si = new SourceInserter(stripped)
    Executor.execute(iFullName, si, classLoader)
    println("done")
    si.currentContents
  }
}