package org.scalaide.worksheet.eval

import org.eclipse.jface.text.IDocument

import java.io.ByteArrayOutputStream
import java.io.FileWriter
import java.io.PrintStream

import scala.reflect.runtime.universe.NoSymbol
import scala.reflect.runtime.universe.TermName
import scala.reflect.runtime.universe.definitions
import scala.reflect.runtime.universe.runtimeMirror
import scala.reflect.runtime.universe.stringToTermName
import scala.tools.eclipse.ScalaPlugin
import scala.tools.eclipse.ScalaProject
import scala.tools.eclipse.buildmanager.sbtintegration.BasicConfiguration
import scala.tools.eclipse.buildmanager.sbtintegration.ScalaCompilerConf
import scala.tools.eclipse.logging.HasLogger
import scala.tools.nsc.CompilerCommand
import scala.tools.nsc.interpreter.AbstractFileClassLoader
import scala.tools.nsc.io.AbstractFile
import scala.tools.nsc.io.VirtualDirectory
import scala.tools.nsc.reporters.StoreReporter

/** An evaluator for worksheet documents.
 *
 *  It evaluates the contents of the given document and returns the sourcecode
 *  augmented with comments containing the result of the evaluation of each expression
 *  in the file.
 *
 */
class WorksheetEvaluator(scalaProject: ScalaProject, doc: IDocument) extends HasLogger {

  /** Evaluate the instrumented code and return the result of the execution.
   *  It is typically the original source code with comments containing the reulst of
   *  the evaluation of each expression.
   *
   *  @param fullName The full name of the main class
   *  @param instrumented The instrumented source code (typically returned from `askInstrumented`)
   */
  def eval(fullName: String, instrumented: Array[Char]): Either[StoreReporter, String] = {
    val iSourceName = writeInstrumented(fullName, instrumented)

    // TODO: extract a better API for getting the configuration of the Scala compiler (should be in ScalaProject)
    val conf = new BasicConfiguration(scalaProject, ScalaCompilerConf.deployedInstance, scalaProject.outputFolderLocations :+ ScalaPlugin.plugin.compilerClasses.get)
    
    val args = conf.buildArguments(List()).toList
    logger.debug("Compilation arguments: " + args)
    val (vdirOpt, reporter) = compileInstrumented(iSourceName, args)
    if (reporter.hasErrors) {
      Left(reporter)
    } else 
      Right(runInstrumented(vdirOpt, fullName, doc.get.toCharArray))
  }

  /** Write instrumented source file to disk.
   *  @param iFullName  The full name of the first top-level object in source
   *  @param iContents  An Array[Char] containing the instrumented source
   *  @return The name of the instrumented source file
   */
  private def writeInstrumented(iFullName: String, iContents: Array[Char]): String = {
    val iSimpleName = iFullName drop ((iFullName lastIndexOf '.') + 1)
    val iSourceName = iSimpleName + "$instrumented.scala"
    val ifile = new FileWriter(iSourceName)
    ifile.write(iContents)
    ifile.close()
    iSourceName
  }

  /** Compile instrumented source file
   *  @param iSourceName The name of the instrumented source file
   *  @param arguments   Further argumenrs to pass to the compiler
   *  @return Optionallu, if no -d option is given, the virtual directory
   *          contained the generated bytecode classes
   */
  private def compileInstrumented(iSourceName: String, arguments: List[String]): (Option[AbstractFile], StoreReporter) = {
    println("compiling " + iSourceName)
    val command = new CompilerCommand(iSourceName :: arguments, println(_))
    val virtualDirectoryOpt =
      if (arguments contains "-d")
        None
      else {
        val vdir = new VirtualDirectory("(memory)", None)
        command.settings.outputDirs setSingleOutput vdir
        Some(vdir)
      }

    val reporter = new StoreReporter()
    val compiler = new scala.tools.nsc.Global(command.settings, reporter)
    val run = new compiler.Run()
    logger.info("compiling: " + command.files)
    run compile command.files

    (virtualDirectoryOpt, reporter)
  }

  /** Run instrumented bytecode file
   *  @param vdir       Optionally, the virtual directory containing the generated bytecode classes
   *  @param iFullName  The full name of the generated object
   *  @param stripped   The contents original source file without any right hand column comments.
   *  @return The generated file content containing original source in the left column
   *          and outputs in the right column
   */
  private def runInstrumented(vdirOpt: Option[AbstractFile], iFullName: String, stripped: Array[Char]): String = {
    val defaultClassLoader = getClass.getClassLoader
    val classLoader = vdirOpt match {
      case Some(vdir) => new AbstractFileClassLoader(vdir, defaultClassLoader)
      case None       => defaultClassLoader
    }
    println("running " + iFullName)

    try {
      import reflect.runtime.universe
      import reflect.runtime.universe._

      val mirror = runtimeMirror(classLoader)
      val mod = mirror.moduleSymbol(classLoader.loadClass(iFullName))
      val meth = mod.typeSignature.member("main": TermName).suchThat(_.typeSignature.resultType.typeSymbol == definitions.UnitClass)

      val baos = new ByteArrayOutputStream
      val outStream = new PrintStream(baos)

      Console.withOut(outStream) {
        if (meth ne NoSymbol) {
          mirror.reflect(mirror.reflectModule(mod).instance).reflectMethod(meth.asMethodSymbol)(Array[String]())
        }
      }
      outStream.close()
      //    Executor.execute(iFullName, si, classLoader)
      baos.toString // TODO: encoding
    } catch {
      case e: Exception =>
        eclipseLog.debug("Error evaluating the worksheet", e)
        stripped.mkString
    }
  }
}